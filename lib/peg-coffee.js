// Generated by CoffeeScript 1.3.3
(function() {
  var PASS_NAME, PEGCoffee;

  PASS_NAME = 'compileFromCoffeeScript';

  PEGCoffee = function(CoffeeScript) {
    return {
      initialize: function(PEG) {
        var appliedPassNames, index;
        if (CoffeeScript == null) {
          CoffeeScript = global.CoffeeScript;
        }
        PEG.compiler.passes[PASS_NAME] = this.pass;
        appliedPassNames = PEG.compiler.appliedPassNames;
        if (appliedPassNames.indexOf(PASS_NAME) === -1) {
          index = appliedPassNames.indexOf('allocateRegister');
          return appliedPassNames.splice(index - 1, 0, PASS_NAME);
        }
      },
      remove: function(PEG) {
        var appliedPassNames, index;
        appliedPassNames = PEG.compiler.appliedPassNames;
        index = appliedPassNames.indexOf(PASS_NAME);
        if (index > -1) {
          appliedPassNames.splice(index, 1);
          return delete PEG.compiler.passes[PASS_NAME];
        }
      },
      pass: function(ast) {
        var compile, compileNode, wrappedInitializer;
        if (ast.initializer == null) {
          ast.initializer = {
            type: 'initializer',
            code: ''
          };
        }
        wrappedInitializer = "__initializer = ( ->\n  " + ast.initializer.code + "\n  return this\n).call({})";
        ast.initializer.code = CoffeeScript.compile(wrappedInitializer, {
          bare: true
        });
        compileNode = function(code) {
          var wrappedCode;
          wrappedCode = "return ( -> " + code + " ).apply(__initializer)";
          return CoffeeScript.compile(wrappedCode, {
            bare: true
          });
        };
        compile = function(nodes) {
          var key, value, _results;
          _results = [];
          for (key in nodes) {
            value = nodes[key];
            if ((value != null) && typeof value === 'object' && value.type !== 'initializer') {
              if (value.code) {
                value.code = compileNode(value.code);
              }
              _results.push(compile(value));
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        };
        return compile(ast);
      }
    };
  };

  (function(define) {
    return define('PEGCoffee', function(require) {
      var CoffeeScript;
      CoffeeScript = require('coffee-script');
      return PEGCoffee(CoffeeScript);
    });
  })(typeof define === 'function' && define.amd ? define : function(id, factory) {
    if (typeof exports !== "undefined" && exports !== null) {
      return module.exports = factory(require);
    } else {
      return window[id] = factory(function(value) {
        return window[value];
      });
    }
  });

}).call(this);
